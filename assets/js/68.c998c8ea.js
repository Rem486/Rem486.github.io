(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{421:function(n,e,t){"use strict";t.r(e);var o=t(40),r=Object(o.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"ecmascript-新特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ecmascript-新特性"}},[n._v("#")]),n._v(" ECMAScript - 新特性")]),n._v(" "),t("p",[n._v("// todo")]),n._v(" "),t("p",[n._v('ES2020-ES11\nES2020 是与 2020 年相对应的 ECMAScript 版本\nString.protype.matchAll\nmatchAll()方法返回一个正则表达式在当前字符串的所有匹配\n不过，它返回的是一个遍历器（Iterator），而不是数组。遍历器转为数组是非常简单的，使用...运算符和 Array.from()方法就可以了。\nconst string = "test1test2test3";\nconst regex = /t(e)(st(\\d?))/g;')]),n._v(" "),t("p",[n._v("const newdata = string.matchAll(regex);")]),n._v(" "),t("p",[n._v('for (const match of newdata) {\nconsole.log(match);\n}\n// ["test1", "e", "st1", "1", index: 0, input: "test1test2test3"]\n// ["test2", "e", "st2", "2", index: 5, input: "test1test2test3"]\n// ["test3", "e", "st3", "3", index: 10, input: "test1test2test3"]')]),n._v(" "),t("p",[n._v("// 转为数组的方法一\n[...newdata];")]),n._v(" "),t("p",[n._v('// 转为数组的方法二\nArray.from(newdata);\n复制代码\n详细内容参考ES 入门-matchAll\nDynamic import\nimport(specifier)函数，支持动态加载模块, import 函数的参数 specifier，指定所要加载的模块的位置。import 命令能够接受什么参数，import()函数就能接受什么参数，两者区别主要是后者为动态加载。\nimport()返回一个 Promise 对象\nconst someVariable = "user";')]),n._v(" "),t("p",[n._v("import("),t("code",[n._v("./some-modules/${someVariable}.js")]),n._v(')\n.then((module) => {\n// 业务逻辑\nmodule.loadPageInto(main);\n})\n.catch((err) => {\n// 加载失败\n});\n复制代码\n详细内容参考ES 入门-import\nPromise.allSettled\nPromise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束\n有时候，我们不关心异步请求的结果，只关心所有的请求有没有结束。这时，Promise.allSettled()方法就很有用\nconst promises = [fetch("index.html"), fetch("https://does-not-exist/")];\nconst results = await Promise.allSettled(promises);')]),n._v(" "),t("p",[n._v('// 过滤出成功的请求\nconst successfulPromises = results.filter((p) => p.status === "fulfilled");')]),n._v(" "),t("p",[n._v('// 过滤出失败的请求，并输出原因\nconst errors = results\n.filter((p) => p.status === "rejected")\n.map((p) => p.reason);\n复制代码\nglobalThis\nES2020 之前获取不同环境的this需要如下封装\nconst getGlobalThis = () => {\n// 在 webworker 或 service worker 中\nif (typeof self !== "undefined") return self;')]),n._v(" "),t("p",[n._v('// 在浏览器中\nif (typeof window !== "undefined") return window;')]),n._v(" "),t("p",[n._v('// 在 Node.js 中\nif (typeof global !== "undefined") return global;')]),n._v(" "),t("p",[n._v('// 独立的 JavaScript shell\nif (typeof this !== "undefined") return this;')]),n._v(" "),t("p",[n._v('throw new Error("Unable to locate global object");\n};\nconst theGlobalThis = getGlobalThis();')]),n._v(" "),t("p",[n._v('if (typeof theGlobalThis.setTimeout !== "function") {\n// 此环境中没有 setTimeout 方法！\n}\n复制代码\n现在，globalThis 提供了一个标准的方式来获取不同环境下的全局 this  对象（也就是全局对象自身）\nif (typeof globalThis.setTimeout !== "function") {\n// 此环境中没有 setTimeout 方法！\n}\n复制代码\n详细内容参考MDN-globalThis\n空位合并操作符（Nullish coalescing Operator）\n在 JS 中，?? 运算符被称为非空运算符。如果第一个参数不是 null/undefined（这里只有两个假值，但是 JS 中假值包含：未定义 undefined、空对象 null、数值 0、空数字 NaN、布尔 false，空字符串\'\'，不要搞混了），将返回第一个参数，否则返回第二个参数。比如，\nnull ?? 5; // => 5\n3 ?? 5; // => 3\n复制代码\n给变量设置默认值时，以前常用 ||逻辑或运算符，例如，\nconst prevMoney = 1;\nconst currMoney = 0;\nconst noAccount = null;\nconst futureMoney = -1;\nfunction moneyAmount(money) {\nreturn money || '),t("code",[n._v("账户未开通")]),n._v(";\n}\nconsole.log(moneyAmount(prevMoney)); // => 1\nconsole.log(moneyAmount(currMoney)); // => 账户未开通\nconsole.log(moneyAmount(noAccount)); // => 账户未开通\nconsole.log(moneyAmount(futureMoney)); // => -1\n复制代码\n上面我们创建了函数 moneyAmount，它返回当前用户余额。我们使用 || 运算符来识别没有帐户的用户。然而，当用户没有帐户时，这意味着什么？将无账户视为空而不是 0 更为准确，因为银行账户可能没有（或负）货币。在上面的例子中，|| 运算符将 0 视为一个虚假值，不应该包括用户有 0 美元的帐户。让我们使用?? 非空运算符来解决这个问题：\nconst currMoney = 0;\nconst noAccount = null;\nfunction moneyAmount(money) {\nreturn money ?? "),t("code",[n._v("账户未开通")]),n._v(";\n}\nmoneyAmount(currMoney); // => 0\nmoneyAmount(noAccount); // => "),t("code",[n._v("账户未开通")]),n._v('\n复制代码\n概括地说 ?? 运算符允许我们在忽略错误值（如 0 和空字符串）的同时指定默认值。\n可选链操作符（Optional Chaining）\n?. 也叫链判断运算符。它允许开发人员读取深度嵌套在对象链中的属性值，而不必验证每个引用。当引用为空时，表达式停止计算并返回 undefined。比如：\nvar travelPlans = {\ndestination: "DC",\nmonday: {\nlocation: "National Mall",\nbudget: 200,\n},\n};\nconsole.log(travelPlans.tuesday?.location); // => undefined\n复制代码\n现在，把我们刚刚学到的结合起来\nfunction addPlansWhenUndefined(plans, location, budget) {\nif (plans.tuesday?.location == undefined) {\nvar newPlans = {\nplans,\ntuesday: {\nlocation: location ?? "公园",\nbudget: budget ?? 200,\n},\n};\n} else {\nnewPlans ??= plans; // 只有 newPlans 是 undefined 时，才覆盖\nconsole.log("已安排计划");\n}\nreturn newPlans;\n}\n// 对象 travelPlans 的初始值，来自上面一个例子\nvar newPlans = addPlansWhenUndefined(travelPlans, "Ford 剧院", null);\nconsole.log(newPlans);\n// => { plans:\n// { destination: \'DC\',\n// monday: { location: \'国家购物中心\', budget: 200 } },\n// tuesday: { location: \'Ford 剧院\', budget: 200 } }\nnewPlans = addPlansWhenUndefined(newPlans, null, null);\n// logs => 已安排计划\n// returns => newPlans object\n复制代码\n上面的例子包含了我们到目前为止所学的所有运算符。现在我们已经创建了一个函数，该函数将计划添加到当前没有嵌套属性的对象 tuesday.location 中。我们还使用了非空运算符来提供默认值。此函数将错误地接受像“0”这样的值作为有效参数。这意味着 budget 可以设置为零，没有任何错误。\nBigInt primitive type\n旧版本的 JS 标准最大的整数只能是253 - 1， 现在使用BigInt 用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。 这是 ECMAScript 的又一种数据类型。\n可以用在一个整数字面量后面加 n 的方式定义一个 BigInt ，如：10n，或者调用函数 BigInt()。\nconst theBiggestInt = 9007199254740991n;')]),n._v(" "),t("p",[n._v("const alsoHuge = BigInt(9007199254740991);\n// ↪ 9007199254740991n\n复制代码")]),n._v(" "),t("p",[n._v("ES 入门-BigInt")]),n._v(" "),t("p",[n._v('ES2019-ES10\nArray#{flat,flatMap}\n数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。\n[1, 2, [3, 4]].flat();\n// [1, 2, 3, 4]\n复制代码\nflatMap()只能展开一层数组。\n// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()\n[1, 2, 3, 4].flatMap((x) => [[x * 2]]);\n// [[2], [4], [6], [8]]\n复制代码\n详细内容参考ES 入门-flat\nObject.fromEntries\nObject.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象。\nObject.fromEntries([\n["foo", "bar"],\n["baz", 42],\n]);\n// { foo: "bar", baz: 42 }\n复制代码\n该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象。\n// 例一\nconst entries = new Map([\n["foo", "bar"],\n["baz", 42],\n]);')]),n._v(" "),t("p",[n._v('Object.fromEntries(entries);\n// { foo: "bar", baz: 42 }')]),n._v(" "),t("p",[n._v('// 例二\nconst map = new Map().set("foo", true).set("bar", false);\nObject.fromEntries(map);\n// { foo: true, bar: false }\n复制代码\nString#{trimStart,trimEnd}\nES2019 对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。\nconst s = "  abc  ";')]),n._v(" "),t("p",[n._v('s.trim(); // "abc"\ns.trimStart(); // "abc  "\ns.trimEnd(); // "  abc"\n复制代码\nSymbol#description\nES2019 提供了一个实例属性description，直接返回 Symbol 的描述。\n// 创建 Symbol 的时候，可以添加一个描述。\nconst sym = Symbol("foo");')]),n._v(" "),t("p",[n._v('sym.description; // "foo"\n复制代码\n上面代码中，sym 的描述就是字符串 foo。\ntry { } catch {} // optional binding\n旧版本的try / catch语句中的catch子句需要一个变量。 现在可以不加了\n// 旧版本\ntry {\nconsole.log(a);\n} catch (error) {\nconsole.log("报错了");\n}')]),n._v(" "),t("p",[n._v('// ES2019-SE10\ntry {\nconsole.log(a);\n} catch {\nconsole.log("报错了");\n}\n复制代码\nU+2028 和 U+2029\n在 ES2019 之前的版本中，不接受不转义的')]),n._v(" "),t("p",[n._v("行分隔符U + 2028\n段落分隔符U + 2029")]),n._v(" "),t("p",[n._v("ES2019 允许 JavaScript 字符串直接输入 U+2028（行分隔符）和 U+2029（段分隔符）。\n/*\nES2019之前，下面的代码会报错")]),n._v(" "),t("p",[n._v('ES2019 下面代码不会报错。\n*/\nconst PS = eval("\'\\u2029\'");\n复制代码\nES 入门-U+2028 和 U+2029\nJSON-stringify-的改造\n为了确保返回的是合法的 UTF-8 字符，ES2019 改变了 JSON.stringify()的行为。如果遇到 0xD800 到 0xDFFF 之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。\nJSON.stringify("\\u{D834}"); // ""\\uD834""\nJSON.stringify("\\uDF06\\uD834"); // ""\\udf06\\ud834""\n复制代码\nES 入门-JSON-stringify-的改造\nArray.prototype.sort() 的稳定排序\n早先的 ECMAScript 没有规定，Array.prototype.sort()的默认排序算法是否稳定，留给浏览器自己决定，这导致某些实现是不稳定的。ES2019 明确规定，Array.prototype.sort()的默认排序算法必须稳定。这个规定已经做到了，现在 JavaScript 各个主要实现的默认排序算法都是稳定的。\nconst arr = ["peach", "straw", "apple", "spork"];')]),n._v(" "),t("p",[n._v("const stableSorting = (s1, s2) => {\nif (s1[0] < s2[0]) return -1;\nreturn 1;\n};")]),n._v(" "),t("p",[n._v('arr.sort(stableSorting);\n// ["apple", "peach", "straw", "spork"]\n复制代码\nES 入门-排序稳定性\nrevised Function#toString\nES2019 对函数实例的 toString()方法做出了修改。\ntoString()方法返回函数代码本身，以前会省略注释和空格。\nfunction /* foo comment */ foo() {}')]),n._v(" "),t("p",[n._v("// 老版本\nfoo.toString();\n// function foo() {}")]),n._v(" "),t("p",[n._v('// 新版\nfoo.toString();\n// "function /* foo comment */ foo () {}"\n复制代码')]),n._v(" "),t("p",[n._v('ES2018-ES9\n解除模板字面量限制(Lifting template literal restriction).\nES2018 放松了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回undefined，而不是报错，并且从raw属性上面可以得到原始字符串。\nfunction tag(strs) {\nstrs[0] === undefined\nstrs.raw[0] === "\\unicode and \\u{55}";\n}\ntag'),t("code",[n._v("\\unicode and \\u{55}")]),n._v("\n复制代码\n上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript 引擎将第一个字符设置为undefined，但是raw属性依然可以得到原始字符串，因此tag函数还是可以对原字符串进行处理。")]),n._v(" "),t("p",[n._v("ES 入门-模板字符串的限制\nES 入门-row\nES 入门-修饰符：u")]),n._v(" "),t("p",[n._v('正则之 s 修饰符：dotAll 模式-(s (dotAll) flag for regular expressions).\nES2018 引入 s 修饰符，使得.可以匹配任意单个字符。\n/foo.bar/s.test("foo\\nbar"); // true\n复制代码\n这被称为dotAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。\nES 入门-修饰符：dotAll 模式\n正则之具名组匹配(RegExp named capture groups)\nES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。')]),n._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("const")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[n._v("RE_DATE")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token regex"}},[t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[n._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[n._v("(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})")]),t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[n._v("/")])]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("const")]),n._v(" matchObj "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[n._v("RE_DATE")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[n._v("exec")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"1999-12-31"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("const")]),n._v(" year "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" matchObj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),n._v("groups"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),n._v("year"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[n._v('// "1999"')]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("const")]),n._v(" month "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" matchObj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),n._v("groups"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),n._v("month"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[n._v('// "12"')]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("const")]),n._v(" day "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" matchObj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),n._v("groups"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),n._v("day"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[n._v('// "31"')]),n._v("\n")])]),n._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[n._v("1")]),t("br"),t("span",{staticClass:"line-number"},[n._v("2")]),t("br"),t("span",{staticClass:"line-number"},[n._v("3")]),t("br"),t("span",{staticClass:"line-number"},[n._v("4")]),t("br"),t("span",{staticClass:"line-number"},[n._v("5")]),t("br")])]),t("p",[n._v('ES 入门-修饰符：具名组匹配\nRest/Spread Properties.\nES6 为数组引入了扩展运算符的写法，\n在 ES2018 中，为对象也引入了此写法\nconst obj = { a: "a", b: "b", c: "c", d: "d", e: "e" };')]),n._v(" "),t("p",[n._v("// 对象结构\nconst { a, b, c, ...rest } = obj;")]),n._v(" "),t("p",[n._v('// 组成新对象\nconst newObj = { a, ...rest };\n复制代码\n正则之后行断言(RegExp Lookbehind Assertions.)\nES2018 引入后行断言\n“后行断言”指: x只有不在y后面才匹配，必须写成/(?<!y)x/。比如，只匹配不在美元符号后面的数字，要写成/(?<!$)\\d+/。\n/(?<=$)\\d+/.exec(\'Benjamin Franklin is on the $100 bill\')  // ["100"]\n/(?<!$)\\d+/.exec(\'it’s is worth about €90\')                // ["90"]\n复制代码\n使用后行断言进行字符串替换。\nconst RE_DOLLAR_PREFIX = /(?<=$)foo/g;\n"$foo %foo foo".replace(RE_DOLLAR_PREFIX, "bar");\n// \'$bar %foo foo\'\n复制代码\nES 入门-后行断言\nUnicode 属性类(RegExp Unicode Property Escapes)\nES2018 引入了一种新的类的写法\\p{...}和\\P{...}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。\nconst regexGreekSymbol = /\\p{Script=Greek}/u;\nregexGreekSymbol.test("π"); // true')]),n._v(" "),t("p",[n._v("// 匹配所有空格\nconst reg = /\\p{White_Space}/;")]),n._v(" "),t("p",[n._v('// 匹配所有的箭头字符\nconst regexArrows = /^\\p{Block=Arrows}+$/u;\nregexArrows.test("←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩"); // true\n复制代码\nES 入门-Unicode 属性类\nPromise.prototype.finally.\nfinally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。\npromise\n.then(result => {···})\n.catch(error => {···})\n.finally(() => {···});\n复制代码\n上面代码中，不管 promise 最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。\nES 入门-finally\n按顺序完成异步操作(Asynchronous Iteration)\n实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。\nasync function logInOrder(urls) {\n// 并发读取远程URL\nconst textPromises = urls.map(async (url) => {\nconst response = await fetch(url);\nreturn response.text();\n});')]),n._v(" "),t("p",[n._v('// 按次序输出\nfor (const textPromise of textPromises) {\nconsole.log(await textPromise);\n}\n}\n复制代码\nasync function getData() {\nconst promises = [fetch("url1"), fetch("url2"), fetch("url3"), fetch("url4")];\nfor (const item of promises) {\n// 打印出promise\nconsole.log(item);\n}')]),n._v(" "),t("p",[n._v("for await (const item of promises) {\n// 打印出请求的结果\nconsole.log(item);\n}\n}\n复制代码\nES 入门-顺序异步操作")]),n._v(" "),t("p",[n._v('ES2017-ES8\nObject.values/Object.entries\nObject.values 方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。\nconst obj = { foo: "bar", baz: 42 };\nObject.values(obj);\n// ["bar", 42]')]),n._v(" "),t("p",[n._v('const obj = { 100: "a", 2: "b", 7: "c" };\nObject.values(obj);\n// ["b", "c", "a"]\n复制代码\nObject.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。\nconst obj = { foo: "bar", baz: 42 };\nObject.entries(obj);\n// [ ["foo", "bar"], ["baz", 42] ]\n复制代码\nObject.entries 的基本用途是遍历对象的属性。\nlet obj = { one: 1, two: 2 };\nfor (let [k, v] of Object.entries(obj)) {\nconsole.log('),t("code",[n._v("${JSON.stringify(k)}: ${JSON.stringify(v)}")]),n._v(');\n}\n// "one": 1\n// "two": 2\n复制代码\nObject.entries 方法的另一个用处是，将对象转为真正的 Map 结构。\nconst obj = { foo: "bar", baz: 42 };\nconst map = new Map(Object.entries(obj));\nmap; // Map { foo: "bar", baz: 42 }\n复制代码\nString padding\nES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。\n"x".padStart(5, "ab"); // \'ababx\'\n"x".padStart(4, "ab"); // \'abax\'')]),n._v(" "),t("p",[n._v('"x".padEnd(5, "ab"); // \'xabab\'\n"x".padEnd(4, "ab"); // \'xaba\'\n复制代码\npadStart()的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。\n"1".padStart(10, "0"); // "0000000001"\n"12".padStart(10, "0"); // "0000000012"\n"123456".padStart(10, "0"); // "0000123456"\n复制代码\n另一个用途是提示字符串格式。\n"12".padStart(10, "YYYY-MM-DD"); // "YYYY-MM-12"\n"09-12".padStart(10, "YYYY-MM-DD"); // "YYYY-09-12"\n复制代码\nObject.getOwnPropertyDescriptors\nES2017 引入了 Object.getOwnPropertyDescriptors()方法，返回指定对象所有自身属性（非继承属性）的描述对象。')]),n._v(" "),t("p",[n._v("value — 属性实际的值\nwritable — 属性的值是否可以被修改\nget — 获取函数，在读取属性时调用\nset — 设置函数，在写入属性时调用\nconfigurable — 属性是否可以通过 delete 删除并重新定义，是否可以修改它的特 性，以及是否可以把它改为访问器属性\nenumerable — 属性是否可以通过 for-in 循环返回")]),n._v(" "),t("p",[n._v('const obj = {\nfoo: 123,\nget bar() {\nreturn "abc";\n},\n};')]),n._v(" "),t("p",[n._v("Object.getOwnPropertyDescriptors(obj);\n// { foo:\n//    { value: 123,\n//      writable: true,\n//      enumerable: true,\n//      configurable: true },\n//   bar:\n//    { get: [Function: get bar],\n//      set: undefined,\n//      enumerable: true,\n//      configurable: true } }\n复制代码\n该方法的引入目的，主要是为了解决 Object.assign()无法正确拷贝 get 属性和 set 属性的问题。\nObject.getOwnPropertyDescriptors()方法的另一个用处，是配合 Object.create()方法，将对象属性克隆到一个新对象。这属于浅拷贝。\nconst shallowClone = (obj) =>\nObject.create(\nObject.getPrototypeOf(obj),\nObject.getOwnPropertyDescriptors(obj),\n);\n复制代码\n更多详细内容参考ES 入门教程-getOwnPropertyDescriptors\n函数参数的尾逗号\nES2017 允许函数的最后一个参数有尾逗号（trailing comma）。\n此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。\nfunction clownsEverywhere(param1, param2,) {\n/* ... */\n}")]),n._v(" "),t("p",[n._v('clownsEverywhere("foo", "bar",);\n复制代码\n更多详细内容参考ES 入门教程-函数参数的尾逗号\n异步函数(Async functions)\nES2017 标准引入了 async 函数，使得异步操作变得更加方便。\nasync 函数是什么？一句话，它就是 Generator 函数的语法糖。\nfunction fakeRequest() {\nreturn new Promise((resolve, reject) => {\nsetTimeout(() => {\nresolve("请求成功");\n}, 2000);\n});\n}')]),n._v(" "),t("p",[n._v('async function getData() {\nconsole.log("start");\nconst res = await fakeRequest();\nconsole.log(res);\nconsole.log("end");\n}\ngetData();\n/*\n1.start\n2.请求成功\n3.end\n*/\n复制代码\n使用 Atomics 共享内存\nAtomics 对象提供了一组静态方法对 SharedArrayBuffer 和 ArrayBuffer 对象进行原子操作。\n更多详细内容参考MDN-Atomics')]),n._v(" "),t("p",[n._v("ES2016-ES7\nArray.prototype.includes\nArray.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。\n[1, 2, 3]\n.includes(2) // true\n[(1, 2, 3)].includes(4) // false\n[(1, 2, NaN)].includes(NaN); // true\n复制代码\n求幂运算符(Exponentiation operator)\n// 2的平方\n2 ** 2; // 4\n// 2的三次方\n2 ** 3; // 8\n复制代码\n更多详细内容参考ES 入门教程-指数运算符")]),n._v(" "),t("p",[n._v("ES2015-ES6\n推荐阮一峰大佬的ES 入门教程,中文文档没有比他更详细的了\n箭头函数(arrows)\n箭头函数是使用=>语法的函数简写。与一般函数不同的是")]),n._v(" "),t("p",[n._v("函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。")]),n._v(" "),t("p",[n._v("this 对象的指向是可变的，但是在箭头函数中，它是固定的。")]),n._v(" "),t("p",[n._v("不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。\n不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。\n不可以使用yield命令，因此箭头函数不能用作 Generator 函数。")]),n._v(" "),t("p",[n._v("var f = (v) => v;")]),n._v(" "),t("p",[n._v("// 等同于\nvar f = function (v) {\nreturn v;\n};")]),n._v(" "),t("p",[n._v('function foo() {\nsetTimeout(() => {\nconsole.log("id:", this.id);\n}, 100);\n}')]),n._v(" "),t("p",[n._v("var id = 21;\n// 箭头函数导致this总是指向函数定义生效时所在的对象（{id: 42}），所以打印出来的是42\nfoo.call({ id: 42 });\n// id: 42")]),n._v(" "),t("p",[n._v("// 对象不构成单独的作用域,使得this指向全局对象\nglobalThis.s = 21;\nconst obj = {\ns: 42,\nm: () => console.log(this.s),\n};")]),n._v(" "),t("p",[n._v("obj.m(); // 21\n复制代码\n更多详细内容参考ES 入门教程-箭头函数\n类(Class)\n// ES5\nfunction Point(x, y) {\nthis.x = x;\nthis.y = y;\n}")]),n._v(" "),t("p",[n._v('Point.prototype.toString = function () {\nreturn "(" + this.x + ", " + this.y + ")";\n};')]),n._v(" "),t("p",[n._v("var p = new Point(1, 2);")]),n._v(" "),t("p",[n._v("// ES6\nclass Point {\nconstructor(x, y) {\nthis.x = x;\nthis.y = y;\n}")]),n._v(" "),t("p",[n._v('toString() {\nreturn "(" + this.x + ", " + this.y + ")";\n}\n}\n复制代码\n更多详细内容参考ES 入门教程-Class\n对象的扩展(enhanced object literals)\n对象的属性的简洁表示法\nconst foo = "bar";\nconst method = function () {\nreturn "Hello!";\n};')]),n._v(" "),t("p",[n._v('const filed = "name";')]),n._v(" "),t("p",[n._v('const baz = {\nfoo,\nmethod,\n[filed]: "小王",\n};')]),n._v(" "),t("p",[n._v('// 等同于\nconst baz = {\nfoo: foo,\nmethod: function () {\nreturn "Hello!";\n},\nname: "小王",\n};\n复制代码\n更多详细内容参考ES 入门教程-对象扩展\n模板字符串\n// 字符串中嵌入变量\nlet name = "Bob",\ntime = "today";\n'),t("code",[n._v("Hello ${name}, how are you ${time}?")]),n._v(";\n复制代码\n更多详细内容参考ES 入门教程-字符串模板\n数组解构+扩展运算符\nvar [a] = [];")]),n._v(" "),t("p",[n._v("a === undefined; // true")]),n._v(" "),t("p",[n._v('var [a = 1] = [];\na === 1; // true\n复制代码\n更多详细内容参考ES 入门教程-数组的扩展运算符\n函数默认参数+剩余参数+扩展运算符\n//如果没有传递y 或者y===undefined ，则y=12\nfunction f(x, y = 12) {\nreturn x + y;\n}\nf(3) == 15;\n复制代码\nfunction f(x, ...y) {\n// y 是一个数组\nreturn x * y.length;\n}\nf(3, "hello", true) == 6;\n复制代码\nfunction f(x, y, z) {\nreturn x + y + z;\n}\n// Pass each elem of array as argument\nf(...[1, 2, 3]) == 6;\n复制代码\n更多详细内容参考ES 入门教程-函数默认参数\n块级作用域变量\n随着 ES6 中引入 let/const 关键字，JS 才具有函数作用域和全局作用域，现在 JS 也可以有块级作用域了。\nfunction f() {\n{\nlet x;\n{\n// 正常，因为在一个新的块级作用域中\nconst x = "sneaky";\n// const 定义的是常量无法被修改，因此会报错\nx = "foo";\n}\n// 在块级作用域中已声明x,因此会报错\nlet x = "inner";\n}\n}\n复制代码\n更多详细内容参考ES 入门教程-unicode\n遍历/迭代器+for..of(iterators + for..of)\n一个数据结构只要部署了 Symbol.iterator 属性，就被视为具有 iterator 接口，就可以用 for...of 循环遍历它的成员。也就是说，for...of 循环内部调用的是数据结构的 Symbol.iterator 方法。\nfor ... of是for ... in和forEach()的替代方法，它循环访问可迭代的数据结构，如数组，映射，集合和字符串。\nJavaScript 原有的 for...in 循环，只能获得对象的键名，不能直接获取键值。ES6 提供 for...of 循环，允许遍历获得键值。\nvar arr = ["a", "b", "c", "d"];')]),n._v(" "),t("p",[n._v("for (let a in arr) {\nconsole.log(a); // 0 1 2 3\n}")]),n._v(" "),t("p",[n._v("for (let a of arr) {\nconsole.log(a); // a b c d\n}")]),n._v(" "),t("p",[n._v('const str = "helloworld";\nfor (let a of str) {\nconsole.log(a); // h e l l o w o r l d\n}\n复制代码\n更多详细内容参考ES 入门教程-iterators\n生成器(generators)\nGenerators 使用function *和yield简化了迭代器的创建。 声明为function '),t("em",[n._v("的函数一个遍历器对象，也就是说，Generator 函数是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\n生成器是迭代器的子类型，因此具有next和throw方法。\nyield表达式是暂停执行的标记，而next方法可以恢复执行\n注意：ES7 出现后,推荐使用await。\nfunction")]),n._v(" foo() {\nyield 1;\nyield 2;\nyield 3;\nyield 4;\nyield 5;\nreturn 6;\n}")]),n._v(" "),t("p",[n._v("for (let v of foo()) {\nconsole.log(v);\n}\n// 1 2 3 4 5\n复制代码\n下面是一个利用 Generator 函数和for...of循环，实现斐波那契数列的例子。\nvar fibonacci = {\n[Symbol.iterator]: function* () {\nlet [prev, curr] = [0, 1];\nfor (;😉 {\nyield curr;\n[prev, curr] = [curr, prev + curr];\n}\n},\n};")]),n._v(" "),t("p",[n._v("for (var n of fibonacci) {\n//\nif (n > 1000) break;\nconsole.log(n);\n}\n复制代码\n从上面代码可见，使用for...of语句时不需要使用next方法。\n利用for...of循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有迭代器接口，无法使用for...of循环，通过 Generator 函数为它加上这个接口，就可以用了。\n生成器(Generator) 实质上继承了迭代器(Iterator)\ninterface Generator extends Iterator {\nnext(value?: any): IteratorResult;\nthrow(exception: any);\n}\n复制代码\n更多详细内容参考ES 入门教程-iterators\nUnicode\nES6 增强了 Unicode 的功能,包括")]),n._v(" "),t("p",[n._v("支持字符的 Unicode 表示法")]),n._v(" "),t("p",[n._v('举例来说，“中”的 Unicode 码点是 U+4e2d，你可以直接在字符串里面输入这个汉字，也可以输入它的转义形式\\u4e2d，两者是等价的。\n"中" === "\\u4e2d"; // true\n复制代码')]),n._v(" "),t("p",[n._v("使用/u匹配码点的正则表达式")]),n._v(" "),t("p",[n._v('// new RegExp behaviour, opt-in ‘u’\n"𠮷".match(/./u)[0].length == 2;\n复制代码')]),n._v(" "),t("p",[n._v("获取 32 位的 UTF-16 字符的码点-codePointAt")]),n._v(" "),t("p",[n._v('"𠮷".codePointAt(0) == 0x20bb7;')]),n._v(" "),t("p",[n._v('let s = "𠮷a";\nfor (let ch of s) {\nconsole.log(ch.codePointAt(0).toString(16));\n}\n// 20bb7\n// 61\n复制代码\n更多详细内容参考ES 入门教程-unicode\n模块化(modules)\nES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。\n使用 export default 或 export 进行导出\n// math.js\nexport const pi = 3.141593;')]),n._v(" "),t("p",[n._v('export default function sum(x, y) {\nreturn x + y;\n}\n复制代码\n使用 import 进行导入\n// app.js\nimport sum, { pi } from "./math";')]),n._v(" "),t("p",[n._v('alert("2π = " + sum(pi, pi));\n复制代码\n更多详细内容参考ES 入门教程-module\n模块加载器规则(module loaders)\n模块加载器支持:')]),n._v(" "),t("p",[n._v("异步加载\n代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。\n模块之中，顶层的 this 关键字返回 undefined，而不是指向 window。也就是说，在模块顶层使用 this 关键字，是无意义的")]),n._v(" "),t("p",[n._v("//index.js\nconst x = 1;")]),n._v(" "),t("p",[n._v('console.log(x === window.x); //false\nconsole.log(this === undefined); // true\n复制代码\n利用顶层的 this 等于 undefined 这个语法点，可以侦测当前代码是否在 ES6 模块之中。\nconst isNotModuleScript = this !== undefined;\n复制代码\n更多详细内容参考ES 入门教程-module-loader\nimport and export\nMap + Set + Weakmap + Weakset\nES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\n// Sets\nvar s = new Set();\ns.add("hello").add("goodbye").add("hello");\ns.size === 2;\ns.has("hello") === true;\n复制代码\nES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。\n// Maps\nvar m = new Map();\nm.set("hello", 42);\nm.set(s, 34);\nm.get(s) == 34;\n复制代码\nWeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。\nWeakMap 与 Map 的区别有两点。')]),n._v(" "),t("p",[n._v("WeakMap 只接受对象作为键名（null 除外），不接受其他类型的值作为键名。\nWeakMap 的键名所指向的对象，不计入垃圾回收机制。")]),n._v(" "),t("p",[n._v("// Weak Maps\nvar wm = new WeakMap();\nwm.set(s, { extra: 42 });\nwm.size === undefined;\n复制代码\nWeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。")]),n._v(" "),t("p",[n._v("WeakSet 的成员只能是对象，而不能是其他类型的值。\nWeakSet 中的对象都是弱引用")]),n._v(" "),t("p",[n._v("// Weak Sets\nvar ws = new WeakSet();\nws.add({ data: 42 });\n// Because the added object has no other references, it will not be held in the set\n复制代码\n更多详细内容参考ES 入门教程-Set 和 Map\n代理(proxies)\nProxy 用于修改某些操作的默认行为，等同于在语言层面做出修改。 可以用于操作拦截，日志记录/分析等。\n// 代理一个普通对象\nvar target = {};\nvar handler = {\nget: function (receiver, name) {\nreturn "),t("code",[n._v("Hello, ${name}!")]),n._v(";\n},\n};")]),n._v(" "),t("p",[n._v("var p = new Proxy(target, handler);")]),n._v(" "),t("p",[n._v('// true\np.world === "Hello, world!";\n复制代码\n下面是 Proxy 所有可以代理的"元操作"\nvar handler =\n{\nget:...,\nset:...,\nhas:...,\ndeleteProperty:...,\napply:...,\nconstruct:...,\ngetOwnPropertyDescriptor:...,\ndefineProperty:...,\ngetPrototypeOf:...,\nsetPrototypeOf:...,\nenumerate:...,\nownKeys:...,\npreventExtensions:...,\nisExtensible:...\n}\n复制代码\nMDN-handler.get()\n// 代理一个函数对象\nvar target = function () {\nreturn "I am the target";\n};\nvar handler = {\napply: function (receiver, ...args) {\nreturn "I am the proxy";\n},\n};')]),n._v(" "),t("p",[n._v('var p = new Proxy(target, handler);\n//true\np() === "I am the proxy";\n复制代码\n更多详细内容参考ES 入门教程-proxy\nsymbols\nES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值\nSymbol 值通过 Symbol 函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。\nvar MyClass = (function () {\n//\nvar key = Symbol("key");')]),n._v(" "),t("p",[n._v("function MyClass(privateData) {\nthis[key] = privateData;\n}")]),n._v(" "),t("p",[n._v("MyClass.prototype = {\ndoStuff: function () {\nthis[key];\n},\n};")]),n._v(" "),t("p",[n._v("return MyClass;\n})();")]),n._v(" "),t("p",[n._v('var c = new MyClass("hello");\n// true\nconsole.log(c["key"] === undefined);\n复制代码\n创建 Symbol 的时候，可以添加一个描述。\nconst sym = Symbol("foo");\n复制代码\n上面代码中，sym 的描述就是字符串 foo。\nSymbol 作为属性名，遍历对象的时候，该属性不会出现在 for...in、for...of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。\n但是，它也不是私有属性，有一个 Object.getOwnPropertySymbols()方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。\nconst obj = {};\nlet a = Symbol("a");\nlet b = Symbol("b");')]),n._v(" "),t("p",[n._v('obj[a] = "Hello";\nobj[b] = "World";')]),n._v(" "),t("p",[n._v("const objectSymbols = Object.getOwnPropertySymbols(obj);")]),n._v(" "),t("p",[n._v("objectSymbols;\n// [Symbol(a), Symbol(b)]\n复制代码\n更多详细内容参考ES 入门教程-symbol\n期约(promises)\nPromise 是一个用于异步编程的库,里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。 许多现有的 JavaScript 库已经使用了 Promise。\nfunction timeout(duration = 0) {\nreturn new Promise((resolve, reject) => {\nsetTimeout(resolve, duration);\n});\n}")]),n._v(" "),t("p",[n._v('var p = timeout(1000)\n.then(() => {\nreturn timeout(2000);\n})\n.then(() => {\nthrow new Error("hmm");\n})\n.catch((err) => {\nreturn Promise.all([timeout(100), timeout(200)]);\n});\n复制代码\n更多详细内容参考ES 入门教程-promise\nmath + number + string + array + object APIs\n添加了许多类型的扩展方法,包括:Math ,Array ,String ,Object\nNumber.EPSILON;\nNumber.isInteger(Infinity); // false\nNumber.isNaN("NaN"); // false')]),n._v(" "),t("p",[n._v("Math.acosh(3); // 1.762747174039086\nMath.hypot(3, 4); // 5\nMath.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2); // 2")]),n._v(" "),t("p",[n._v('"abcde".includes("cd"); // true\n"abc".repeat(3); // "abcabcabc"')]),n._v(" "),t("p",[n._v('Array.from(document.querySelectorAll("*")); // Returns a real Array\nArray.of(1, 2, 3) // Similar to new Array(...), but without special one-arg behavior\n[(0, 0, 0)].fill(7, 1) // [0,7,7]\n[(1, 2, 3)].find((x) => x == 3) // 3\n[(1, 2, 3)].findIndex((x) => x == 2) // 1\n[(1, 2, 3, 4, 5)].copyWithin(3, 0) // [1, 2, 3, 1, 2]\n[("a", "b", "c")].entries() // iterator [0, "a"], [1,"b"], [2,"c"]\n[("a", "b", "c")].keys() // iterator 0, 1, 2\n[("a", "b", "c")].values(); // iterator "a", "b", "c"')]),n._v(" "),t("p",[n._v("Object.assign(Point, { origin: new Point(0, 0) });\n复制代码\n更多详细内容参考 ES 入门教程:")]),n._v(" "),t("p",[n._v("Number\nMath,\nArray.from\nArray.of\nArray.prototype.copyWithin\nObject.assign")]),n._v(" "),t("p",[n._v("二进制和八进制(binary and octal literals)\n两种新的数字表示形式。")]),n._v(" "),t("p",[n._v("二进制: 0b 开头\n八进制: 0o 开头")]),n._v(" "),t("p",[n._v('0b111110111 === 503; // true\n0o767 === 503; // true\n复制代码\nreflect api\nreflect API 公开对象上的运行时级别的元操作。\n最重要的目的是配合 Proxy 使用，执行原生行为\n让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。\n// 老写法\n"assign" in Object; // true')]),n._v(" "),t("p",[n._v('// 新写法\nReflect.has(Object, "assign"); // true\n复制代码\n更多详细内容参考ES 入门教程-reflect\n尾调用(tail calls)')]),n._v(" "),t("p",[n._v("尾调用:某个函数的最后一步是返回并调用另一个函数\n尾递归:函数调用自身，称为递归。如果尾调用自身，就称为尾递归。\n尾调用优化")]),n._v(" "),t("p",[n._v("注意，目前只有 Safari 浏览器支持尾调用优化，Chrome 和 Firefox 都不支持。这里就不深入研究了 😁\nfunction factorial(n, acc = 1) {\nif (n <= 1) return acc;\nreturn factorial(n - 1, n * acc);\n}")]),n._v(" "),t("p",[n._v("// 大多数浏览器中都会出现 堆栈溢出 的错误,\n// 但是在 ES6的Safari中是安全的\nfactorial(100000);\n复制代码\n更多详细内容参考ES 入门教程-尾调用\n通过 Intl API 对字符串，数字和日期进行国际化\nIntl 对象是 ECMAScript 国际化 API 的命名空间，它提供对语言敏感的字符串比较、支持数字格式化以及日期和时间的格式化。\nIntl.Collator 对象\ncollator 这个单词意思是排序器。Intl.Collator 对象是排序器的构造函数，可以支持对语言敏感的字符串比较。")]),n._v(" "),t("p",[n._v("中文排序")]),n._v(" "),t("p",[n._v('如果我们希望我们的中文按照首字母拼音排序，该怎么处理？\n此时，可以使用中文简体的 BCF 47 语言标记字符串 zh 进行排序，代码如下：\nvar arrUsername = [\n"陈坤",\n"邓超",\n"杜淳",\n"冯绍峰",\n"韩庚",\n"胡歌",\n"黄晓明",\n"贾乃亮",\n"李晨",\n"李易峰",\n"鹿晗",\n"井柏然",\n"刘烨",\n"陆毅",\n"孙红雷",\n];')]),n._v(" "),t("p",[n._v('arrUsername.sort(new Intl.Collator("zh").compare);\n// 结果是：["陈坤", "邓超", "杜淳", "冯绍峰", "韩庚", "胡歌", "黄晓明", "贾乃亮", "井柏然", "李晨", "李易峰", "刘烨", "陆毅", "鹿晗", "孙红雷"]\n复制代码\nIntl API详细可以参考这篇文章JS Intl 对象完整简介及在中文中的应用')]),n._v(" "),t("p",[n._v('ES2011-ES5\n相信大家已经对 ES5 都了然于胸，因此只做简单罗列，就不举例说明了\n\'USE STRICT\'\nJS 的早期版本允许使用未声明的变量。 但是当使用 es5 "use strict"功能时，会报告错误\n// index.js\n"use strict";')]),n._v(" "),t("p",[n._v("// 报错:a is not defined\na = 22;\n复制代码\nArray\nArray.isArray\nArray.forEach\nArray.map\nArray.filter\nArray.reduce\nArray.reduceRight\nArray.every\nArray.some\nArray.indexOf\nArray.lastIndexOf\nJSON\nJSON.parse\nJSON.stringify\nDATE\nDate.now()\nDate.now().valueOf()\nObject.defineProperty()")]),n._v(" "),t("p",[n._v("参考文档")]),n._v(" "),t("p",[n._v("ECMAScript 6 Features\nes6-features.org\nES2021 Features with simple examples\n4 个强大 JavaScript 运算符\nES6 核心特性")])])}),[],!1,null,null,null);e.default=r.exports}}]);