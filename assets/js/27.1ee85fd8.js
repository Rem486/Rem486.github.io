(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{383:function(t,e,r){"use strict";r.r(e);var a=r(42),l=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"mvc-和-mvvm"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mvc-和-mvvm"}},[t._v("#")]),t._v(" MVC 和 MVVM")]),t._v(" "),r("p",[t._v("创建时间：2019-03-05")]),t._v(" "),r("h3",{attrs:{id:"mvc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mvc"}},[t._v("#")]),t._v(" MVC")]),t._v(" "),r("ul",[r("li",[t._v("Model (模型)：是应用程序中用于处理应用程序数据逻辑的部分。通常就是指从接口获取数据库中数据的部分。")]),t._v(" "),r("li",[t._v("View (视图)：是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。")]),t._v(" "),r("li",[t._v("Controller (控制器)：是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。")])]),t._v(" "),r("blockquote",[r("p",[t._v("斯坦福大学公开课上的这幅图来说明，最经典和最规范的MVC标准")])]),t._v(" "),r("p",[r("img",{attrs:{src:"/img/mvc.png",alt:"mvc.png"}})]),t._v(" "),r("p",[t._v("分割开 M , V , C 的线有点像交通标示线。\n虚线：本侧可以通行；\n实现：本侧不可以通行；\n双实现：双向禁止通行；")]),t._v(" "),r("h4",{attrs:{id:"controller-和-view-model"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#controller-和-view-model"}},[t._v("#")]),t._v(" Controller 和 View / Model")]),t._v(" "),r("p",[t._v("可以直接进行引用")]),t._v(" "),r("h4",{attrs:{id:"view-和-controller"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#view-和-controller"}},[t._v("#")]),t._v(" View 和 Controller")]),t._v(" "),r("p",[t._v("单向引用， View 通过策略模式和 Controller 传递事件。\n按钮点击事件，是View来接收的，但是处理这个事件的应该是Controller，所以View把这个事件传递给了Controller，如何传递的呢，见图，看到View上面的action没有，这就是事件，看到Controller上面的target没有，这就是靶子，View究竟要把事件传递给谁，它被规定了传递给靶子，Controller实际上就是靶子。只是View只负责传递事件，不负责关心靶子是谁。就像你是一个负责运货的少年，你唯一知道的是你要把货（action）交给上头（开发者）告诉你的那个收货的人（target），至于那个收货的人是警察还是怪兽，你都不需要关心。这是V和C的一种交互方式，叫做target-action。所以你看，这张图简直就是神来之笔，旁边还栩栩如生的画出了V对C的另一种传值：协议-委托。委托有两种：代理和数据源。什么是代理，就是专门处理should、will、did事件的委托，什么是数据源，就是专门处理data、count等等的委托。")]),t._v(" "),r("h4",{attrs:{id:"model-和-controller"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#model-和-controller"}},[t._v("#")]),t._v(" Model 和 Controller")]),t._v(" "),r("p",[t._v("从MVC出生到现在为止争议比较大的，M和C的交互。")]),t._v(" "),r("p",[t._v("我们从M的作用开始说起。")]),t._v(" "),r("p",[t._v("M是干嘛的？上面说了，M就是数据管理者，你可以理解为它直接和数据库打交道。这里的数据库可能是本地的，也可能是服务器上的，M会从数据库获取数据，也可能把数据上传给数据库。M也将提供属性或者接口来供C访问其持有的数据。我们就拿一个简单的需求作为例子，假如我想在一个模块中显示一段文字，这段文字是从网上获取下来的。")]),t._v(" "),r("p",[t._v("那么使用MVC的话，在C中肯定需要一个UILabel（V）作为属性来显示这段文字，而这段文字由谁来获取呢，肯定是由M来获取了。而获取的地方在哪里呢？通常在C的生命周期里面，所以往往是在C的一个生命周期方法比如viewDidLoad里面调用M获取数据的方法来获取数据。现在问题来了，M获取数据的方法是异步的网络请求，网络请求结束后，C才应该用请求下来的数据重新赋值给V，现在的问题是，C如何知道网络请求结束了？")]),t._v(" "),r("p",[t._v("这里我们一定要换一种角度去思考，我们进一步考虑M和V之间的关系：它们应该是一种同步的关系，也就是，不管任何时刻，只要M的值发生改变，V的显示就应该发生改变（显示最新的M的内容）。所以我们可以关注M的值改变，而不用关心M的网络请求是否结束了。实际上C根本不知道M从哪去拿的数据，C的责任是负责把M最新的数据赋值给V。所以C应该关注的事件是：M的值是否发生了变化。可以通过发布订阅模式来实现。")]),t._v(" "),r("h3",{attrs:{id:"参考资料"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://blog.csdn.net/u013282174/article/details/51220199",target:"_blank",rel:"noopener noreferrer"}},[t._v("MVC和MVVM详解"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://juejin.im/post/593021272f301e0058273468",target:"_blank",rel:"noopener noreferrer"}},[t._v("浅析前端开发中的 MVC/MVP/MVVM 模式"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://www.jianshu.com/p/9fc69a38da50",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue学习系列一 —— MVVM响应式系统的基本实现原理"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=l.exports}}]);