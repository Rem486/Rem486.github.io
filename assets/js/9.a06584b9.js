(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{180:function(t,a,e){"use strict";e.r(a);var r=e(0),s=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"滚动穿透"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#滚动穿透","aria-hidden":"true"}},[t._v("#")]),t._v(" 滚动穿透")]),t._v(" "),e("p",[t._v("创建时间：2019年02月16日")]),t._v(" "),e("h3",{attrs:{id:"遇到的问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#遇到的问题","aria-hidden":"true"}},[t._v("#")]),t._v(" 遇到的问题")]),t._v(" "),e("p",[t._v("移动端开发中，最常遇见的一个场景就是，一个可滑动的列表页，弹出一个带有全屏蒙层的弹框。这个时候如果没有进行处理的话，就会出现，用手滑动蒙层空白处时，滑动事件会穿透到底部列表页，导致弹框虽然固定了，但是列表页会滑动。")]),t._v(" "),e("h3",{attrs:{id:"需解决的问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#需解决的问题","aria-hidden":"true"}},[t._v("#")]),t._v(" 需解决的问题")]),t._v(" "),e("ol",[e("li",[t._v("滑动空白处，底层的列表不会滑动;")]),t._v(" "),e("li",[t._v("弹框内如果需要滚动的时候，可以滚动;")])]),t._v(" "),e("h3",{attrs:{id:"解决方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解决方案","aria-hidden":"true"}},[t._v("#")]),t._v(" 解决方案")]),t._v(" "),e("h4",{attrs:{id:"_1-弹框显示的时候，对于外层的可滚动容器设置-overflow-y-hidden-。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-弹框显示的时候，对于外层的可滚动容器设置-overflow-y-hidden-。","aria-hidden":"true"}},[t._v("#")]),t._v(" 1. 弹框显示的时候，对于外层的可滚动容器设置 overflow-y: hidden 。")]),t._v(" "),e("h4",{attrs:{id:"_2-阻止-touchmove-的默认行为，但是这样会连弹框内的滚动事件一起阻止了，适合不需要滚动的场景。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-阻止-touchmove-的默认行为，但是这样会连弹框内的滚动事件一起阻止了，适合不需要滚动的场景。","aria-hidden":"true"}},[t._v("#")]),t._v(" 2. 阻止 touchmove 的默认行为，但是这样会连弹框内的滚动事件一起阻止了，适合不需要滚动的场景。")])])}],!1,null,null,null);a.default=s.exports}}]);